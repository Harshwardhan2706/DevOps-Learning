DOCKER VERSION ~ 20.10.23

ðŸ”´To install docker ===>>
___________________________________________________________________________________________________________
sudo apt install docker.io
sudo yum/apt install docker -y
-----------------------------------------------------------------------------------------------------------

ðŸ”´To start the service ===>>
__________________________________________________________________________________________________________
service docker status ====>>  to ckeck docker is running or not
service docker start ===>> to start the docker 
----------------------------------------------------------------------------------------------------------

ðŸ”´To create the container ===>>
_________________________________________________________________________________________________________
docker run --name <container name> -it ubuntu /bin/bash ===>> to create container
docker run -it --name <containername> <imagename> /bin/bash ===>> to create the container from image 
docker run -p <host_port>:<container_port> <image_name> [options] ===>> to run docker conyainer at specific port
	<host_port>: This is the port number you want to use on your host machine to access the container's service.
	<container_port>: This is the port number that the service inside the container listens on.

docker run -d --name mysql-db \
         -e MYSQL_ROOT_PASSWORD=db_pass123 \
         mysql:latest  ===>> Set the database password to useÂ db_pass123. Lookup the mysql image on Docker Hub and identify the 			     correct environment variable to use for setting the root password.

docker run -d --name clickcounter --link redis:redis -p 8085:5000 kodekloud/click-counter ===>> 
	create a simple container called clickcounter with the image kodekloud/click-counter, link it to the redis container that 	we created in the previous task and then expose it on the host port 8085


The clickcounter app run on port 5000.
if you are unsure, check the hints section for the exact commands.

docker run -d -p 38282:8080 -e APP_COLOR=blue --name blue-app kodekloud/simple-webapp ===>> 
	to run a container named blue-app using the kodekloud/simple-webapp image, setting the APP_COLOR environment variable to 	blue, and mapping port 38282 on the host to port 8080 within the container:

exit ===>> to come out of container
docker diff <containername> ===>> to see the difference in continer 
	C - change, A - Addition

docker rm <container_name/container_Id> ===>> to remove container
docker rm $(docker ps -a -q) ===>> Delete all stopped container

docker run ubuntu sleep 5 ===>> 
	o Container Creation: Once the image is available, Docker will create a new container based on the "ubuntu" image.
	o Command Execution: The sleep 5 command will be executed inside the newly created container. This command will pause the 	  container for 5 seconds.
	o Container Termination: After 5 seconds, the sleep command finishes, and the container will automatically stop and be 		  removed by default behavior.
docker run -d ubuntu sleep 5 ===>> run in detach mode (run in bg)
docker run -it ubuntu sleep 5 ===>> run in interactive mode, i means interactive mode and t means terminal.

docker run nginx ===>> 
	o Uses the downloaded Nginx image to create and start a running Docker container.
	o Create a new container based on the Nginx image.
	o Start the Nginx web server process inside the container.

docker pull nginx ===>>
	o Downloads the Nginx image from Docker Hub (or another registry) to your local system.

Key Differences:
	o Action: docker pull downloads, docker run creates and runs.
	o Output: docker pull creates a local image, docker run creates a running container.
	o Subsequent Usage: You can run docker run multiple times using the same image to create new containers.

When to use each command:
	o Use docker pull when you don't have the desired image available locally and want to download it for future use.
	o Use docker run when you want to start a new instance of an application or service based on an existing image.

docker ps ===>> to see running container on your docker host
docker ps -a ===>> to list all running and stopped container
docker stop <container name> ===>> use to stop running conatiner
docker stop $(docker ps -a -q) ===>>> stop all running container
docker start <container_name ===>> to start already existing conatainer

docker exec whalesay cat /etc/hosts ===>> use to see content of container's inside the /etc/hosts

docker attach <container> ===>> attach your terminal to a running Docker container.

To detach and return to your host terminal ===>> 	Linux/macOS: Ctrl + P, then Ctrl + Q
							Windows: Ctrl + P, then Enter

docker inspect <container_name> ===>> display detailed information about that specific container.

docker logs <container_name> ===>> display the logs generated by a Docker container.
----------------------------------------------------------------------------------------------------------

ðŸ”´To create images ===>> 
_________________________________________________________________________________________________________
docker commit <containername> <imagename> ===>> to create image
docker build -t test . ===>> to create docker image from docker file
docker images ===>> to see the list of created images
docker rmi nginx ===>> use to remove image 
docker rmi -f nginx ===>> use to remove image even it's being used by running container
docker rmi <image_id> ===>> remove image using image id
docker rmi -f $(docker image -q) ===>> delete all images
---------------------------------------------------------------------------------------------------------

ðŸ”´To create docker file ===>>
_________________________________________________________________________________________________________
Dockerfile === A text file which contains some kset of instruction.
		OR Automation of Docker image creation.

	FROM == for base image command must be on top of docker file.
	RUN == to execute the command it will create layer of image
	MAINTAINER == Author/Owner/Description
	COPY == copy file from local system (docker VM) we need to provide source, destination (we can't download file from any 	internet or remote repo)
	ADD == similar to copy but it provide feature to download file from internet
	EXPOSE == to expose point such as port 8080 for tomcat, port 80 for nginx
	WORKDIR == To set working directory for container
	CMD == excute command but during container creation
	ENTRYPOINT == Similar to CMD but has higher priority over CMD, first command will be executed by ENTRYPOINT only
	ENV == Environment variable


Vi Dockerfile ===>> to create docker file
	FROM ubuntu
	RUN echo "any thing" > /tmp/testfile

vi Dockerfile ===>> 
	FROM ubuntu
	WORKDIR /tmp
	RUN echo "Another way of DOcker file" > /tmp/testfile
	ENV myname Harshwardhan
	COPY testfile1 /tmp
	ADD test.tar.gz /tmp
touch testfile1 ===>> create new file
touch test ===>> create one more file
tar -cvf test.tar test ===>> convert test file into tar file
gzip test.tar ===>> to conver test.tar into zip file
rm -rf test ===>> to remove the file forcefully
docker build -t newimage . ===>> 
docker run -it --name newcontainer newimage /bin/bash ===>>
---------------------------------------------------------------------------------------------------------------------------------------

ðŸ”´ Docker Compose ===>>
______________________________________________________________________________________________________________________________________

Docker Compose is a tool used to define and run multi-container Docker applications. It allows you to configure your entire application's services with a single YAML file.

docker-compose build ===>> to build the images for your services based on the Dockerfiles.

docker-compose up ===>> to start and run all the services defined in your docker-compose.yml file

docker-compose scale ===>> to easily scale the number of instances for each service.

docker-compose logs ==>> you can view the combined logs from all your running services.

ðŸ”˜Compose File (docker-compose.yml): 
	This is the YAML file where you define the services that make up your application, along with their configurations. It specifies things 	like image names, ports, volumes, and environment variables for each service.

			docker compose.yml version 1
					
					redis:
						image: redis
					db:
						image: posgres:9.4
					vote:
						image: vote-app
						ports: 
							-5000:80
						links:
							-redis
					worker:
						image: worker-app
						links:
							-redis
							-db
					result: 
						image: result-app
						ports: 
							-5000:80
						links:
							-db

ðŸ”˜Here's a basic workflow for using Docker Compose:

	o Create Dockerfiles: Define Dockerfiles for each service in your application, specifying the base image, dependencies, and startup 		 
          commands.
	o Create docker-compose.yml: In this YAML file, define your application's services, specifying the corresponding Dockerfile, ports, 			  volumes, and other configurations.
	o Build and Run: Use the docker-compose build command to build the images for your services based on the Dockerfiles. Then, use docker-			  compose up to start and run all the services defined in your docker-compose.yml file.
-----------------------------------------------------------------------------------------------------------------------------------------------


ðŸ”´ Docker Volume ===>> 
_______________________________________________________________________________________________________________________________________
docker run -v /opt/data:/var/lib/mysql -d --name mysql-db -e MYSQL_ROOT_PASSWORD=db_pass123 mysql ===>> 
		Run a mysql container again, but this time map a volume to the container so that the data stored by the container is stored 
                at /opt/data on the host.
		Use the same name : mysql-db and same password: db_pass123 as before. Mysql stores data at /var/lib/mysql inside the container.

yum install docker -y >>>
service docker start >>>>
vi DockerFile >>>>
	FROM ubuntu
	VOLUME ["/myvolume"]
docker build -t  myImage . >>>
docker run -it --name container1 yourimage /bib/bash >>>
container created now go inside the container
	ls >> it will show myvolume as a volume
	cd myvolume >> go insuide the volume
		touch file1 file2 file3 >> create three file 

Now create another contianer to share the volume ======
docker run -it --name container28 --privileged=true --volumes-from container3 ubuntu /bin/bash >>>>>> to copy the volume from one container to another container
	ls >> we'll find myvolume file copied here in this container
		ls >> we find the three file also that's inside myvolume

create volume by using commands ===>>
docker run -it --name harshu3cont -v /volume2 ubuntu /bin/bash >>> to create volume inside the conatiner
	ls >> to check volume2
docker run -it --name harshu4cont --privileged=true --volumes-from harshu3cont ubuntu /bin/bash >>> create another container and copy the volume from another conatiner 
	ls>> to check the volume2 
		cd volume2 >> to check file created 

volume transfer from Host to Container ===>>
	pwd ===>> to check current directory
	cd /home ===>> to go to home directory
	ls ===>> to see the ec2-user
docker run -it --name hostcont -v home/ec2-user:/harshu3cont privileged=true ubuntu /bin/bash ====>> to create container inside the host and

docker volume ls ===>> to see the all avaialbe volumes
docker volume create <volumename> ===>> to create volume
docker volume create rm <volumename> ===>> to delete volume
docker volume prune ===>> it remove all unused docker volume
docker volume inspect <volumename> ===>> to check volume details
docker container inspect <containername> ===>> to check container details
-------------------------------------------------------------------------------------------------------------------------------------------

ðŸ”´ Docker Network ===>>
______________________________________________________________________________________________________________________________________
docker network create --driver bridge --subnet 182.18.0.1/24 --gateway 182.18.0.1 wp-mysql-network ===>> 
	Create a new network named wp-mysql-network using the bridge driver. Allocate subnet 182.18.0.1/24. Configure Gateway 182.18.0.1
docker run -e DB_Password=db_pass123 -e DB_Host=mysql-db --network wp-mysql-network -p 38080:8080 --name  webapp --link mysql-db:mysql-db -d kodekloud/simple-webapp-mysql ===>> 
		Deploy a web application named webapp using the kodekloud/simple-webapp-mysql image. Expose the port to 38080 on the host.
		The application makes use of two environment variable:
		1: DB_Host with the value mysql-db.
		2: DB_Password with the value db_pass123.
		Make sure to attach it to the newly created network called wp-mysql-network.
		Also make sure to link the MySQL and the webapp container.

docker network ls ===>> to check list of network available
docker network inspect bridge ===>> to see all network details
docker run -d --name alpine-2 --network=none alpine ===>> Run a container named alpine-2 using the alpine image and attach it to the none network.

ðŸ”´ Difference between Expose and publish ===>>
_______________________________________________________________________________________________________________________________

!.  If you specify neither expose nor -p the server in the container will only be accesible from inside the container itself.

!!.  If you expose a port, the service in the conatiner is not accessible from the outside the docker, but from inside other 
     docker containers, so this is good for inter container communication.

!!!.  If you expose and -p a port, the service in the container is accessible from anywhere, even outside from docker
-------------------------------------------------------------------------------------------------------------------------------


ðŸ”´Expose the port of the container ===>> 
__________________________________________________________________________________________________________
docker run -td --name techserver -p 80:80 ubuntu >>>>> create the container with port 80
	td>>> will create the container but will not let inside the container
docker ps ===>> to see the running container detaiils
docker port techserver ===>> to see the port number
docker exec -it techserver /bin/bash ===>> to go inside the container
apt-get update ===>> to update in ubuntu
apt-get install apache2 -y ===>> to install apache server
cd /var/www/html ===>> to go inside the dir
	echo "I'm going to kill" >index.html
	service apache2 restart ===>> to start the service again
	After restarting public Ip will run with given messagew body.
------------------------------------------------------------------------------------------------------------

ðŸ”´Docker hub working ===>>
____________________________________________________________________________________________________________
docker login ===>>>
	username:harshu001
	password:PegaSystem
docker tag imagehub harshu001/project1 ===>>> to add image with tag name in docker hub
